% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get-mfrs.r
\name{get_mfrs}
\alias{get_mfrs}
\title{Recover minimal functional routes}
\usage{
get_mfrs(graph, expand = FALSE, input, output, source = NULL,
  target = NULL, algorithm = NULL, silent = TRUE,
  format = "sequences")
}
\arguments{
\item{graph}{An object of class \code{"igraph"}.}

\item{expand}{Whether to expand \code{graph} before finding the MFRs and, if
so, to return the list of MFRs in terms of the node and link IDs of
\code{graph} rather than of its expanded graph.}

\item{input, output}{Nodes of \code{graph}, as \strong{igraph} vertices,
integer indices, or character names.}

\item{source, target}{Deprecated; aliases of \code{input} and \code{output}.}

\item{algorithm}{An algorithm from Wang et al (2013) from among the
following: \code{"dfs"} (depth-first search; Algorithm 1), \code{"ilp"}
(iterative integer linear programming; Algorithm 2), or \code{"sgg"}
(subgraph-growing; Algorithm 3). \strong{Currently Algorithms 1 and 3 are
implemented in C++; Algorithm 3 also has an implementation in R, employed
by passing \code{"sggR"}.}}

\item{silent}{Whether to print updates on the progress of the algorithm
(deprecated).}

\item{format}{Whether to return the list of MFRs as \code{"sequences"} of
link IDs or as \code{"matrices"} of head and tail node IDs.}
}
\description{
This function takes a graph \code{graph} (by default assumed to be expanded)
with designated \code{input} and \code{output} nodes and finds the minimal
functional routes (MFRs) from \code{input} to \code{output}.
}
\examples{
# MFRs for acyclic example (constructs expanded graph internally)
g <- example_acyclic
g_mfrs <- get_mfrs(g, expand = TRUE, input = "I", output = "O")
par(mfrow = c(2, 3))
for (i in seq_along(g_mfrs)) {
  g <- set_edge_attr(g, "MFR",
                     value = (as.numeric(E(g))) \%in\% g_mfrs[[i]])
  plot(g,
       layout = layout_as_tree,
       vertex.color = ifelse(V(g)$composite, "gray", "white"),
       edge.color = ifelse(edge_attr(g, "MFR"), "red", "black"),
       edge.width = ifelse(edge_attr(g, "MFR"), 3, 1))
}
par(mfrow = c(1, 1))
# MFRs for its expanded graph directly
h <- expand_graph(g)
h_mfrs <- get_mfrs(h, input = 1, output = 10)
par(mfrow = c(2, 3))
for (i in seq_along(h_mfrs)) {
  h <- set_edge_attr(h, "MFR",
                     value = (as.numeric(E(h))) \%in\% h_mfrs[[i]])
  plot(h,
       layout = layout_as_tree,
       vertex.color = ifelse(V(h)$composite, "gray", "white"),
       edge.color = ifelse(edge_attr(h, "MFR"), "red", "black"),
       edge.width = ifelse(edge_attr(h, "MFR"), 3, 1))
}
par(mfrow = c(1, 1))
# MFRs from expanded graph converted back to contracted graph
g_ <- contract_graph(h)
par(mfrow = c(2, 3))
for (i in seq_along(h_mfrs)) {
  g_ <- set_edge_attr(g_, "MFR",
                      value = (as.numeric(E(g_))) \%in\% h_mfrs[[i]])
  plot(g_,
       layout = layout_as_tree,
       vertex.color = ifelse(V(g_)$composite, "gray", "white"),
       edge.color = ifelse(edge_attr(g_, "MFR"), "red", "black"),
       edge.width = ifelse(edge_attr(g_, "MFR"), 3, 1))
}
par(mfrow = c(1, 1))

# color duplicated link
g <- example_acyclic
h <- expand_graph(g)
mfrs <- get_mfrs(h, input = 1, output = 10)
h <- set_edge_attr(h, "MFR", value = sapply(
  as.numeric(E(h)),
  function(i) length(which(mfrs[[3]] == i))
))
plot(
  h, layout = layout_as_tree,
  vertex.color = ifelse(V(h)$composite, "gray", "white"),
  edge.color = c("black", "red", "blue")[unlist(edge_attr(h, "MFR")) + 1],
  edge.width = ifelse(edge_attr(h, "MFR"), 3, 1)
)

# subgraph-growing algorithm: toy examples
graph <- graph(c( 1,3, 2,3 ))
graph <- set_vertex_attr(graph, "composite", value = FALSE)
get_mfrs(graph, input = 1, output = 3, algorithm = "sgg", silent = FALSE)
get_mfrs(graph, input = 1, output = 3, algorithm = "sggR", silent = FALSE)

graph <- graph(c( 1,2, 2,3, 1,3, 3,4 ))
plot(graph, edge.label = E(graph))
graph <- set_vertex_attr(graph, "composite", value = FALSE)
get_mfrs(graph, input = 1, output = 4, algorithm = "sgg", silent = TRUE)
get_mfrs(graph, input = 1, output = 4, algorithm = "sggR", silent = TRUE)

graph <- graph(c( 1,2, 1,3, 2,4, 3,4, 4,5, 3,6, 6,5 ))
plot(graph, edge.label = E(graph))
graph <- set_vertex_attr(graph, "composite", value = as.logical(c(0,0,0,1,0,0)))
get_mfrs(graph, input = 1, output = 5, algorithm = "sgg")
get_mfrs(graph, input = 1, output = 5, algorithm = "sggR")

# subgraph-growing algorithm: acyclic example
acyclic_expansion <- expand_graph(example_acyclic)
plot(acyclic_expansion,
     layout = layout_as_tree,
     vertex.color = ifelse(V(acyclic_expansion)$composite, "gray", "white"),
     edge.label = E(acyclic_expansion))
get_mfrs(acyclic_expansion, input = "I", output = "O", algorithm = "dfs")
get_mfrs(acyclic_expansion, input = "I", output = "O", algorithm = "sgg")
get_mfrs(acyclic_expansion, input = "I", output = "O", algorithm = "sggR")

# subgraph-growing algorithm: cyclic example
cyclic_expansion <- expand_graph(example_cyclic)
plot(cyclic_expansion,
     layout = layout_with_fr,
     vertex.color = ifelse(V(cyclic_expansion)$composite, "gray", "white"),
     edge.label = E(cyclic_expansion))
get_mfrs(cyclic_expansion, input = "s", output = "t", algorithm = "sgg")
get_mfrs(cyclic_expansion, input = "s", output = "t", algorithm = "sggR")

\dontrun{
rbenchmark::benchmark(
  get_mfrs(cyclic_expansion, input = "s", output = "t", algorithm = "sgg"),
  get_mfrs(cyclic_expansion, input = "s", output = "t", algorithm = "sggR")
)
rbenchmark::benchmark(
  get_mfrs(acyclic_expansion, input = "I", output = "O", algorithm = "dfs"),
  get_mfrs(acyclic_expansion, input = "I", output = "O", algorithm = "sgg"),
  get_mfrs(acyclic_expansion, input = "I", output = "O", algorithm = "sggR")
)
}
}
\references{
Wang, R.-S., Sun, Z. & Albert, R. (2013) Minimal functional routes in 
directed graphs with dependent links. \emph{Intl. Trans. in Op. Res.}, 20, 
391--409.
}
\seealso{
expand_graph
}
