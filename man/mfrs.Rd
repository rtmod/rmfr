% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get-mfrs.r
\name{mfrs}
\alias{mfrs}
\alias{get_mfrs}
\alias{get_minimal_functional_routes}
\alias{get_minimal_paths}
\title{Recover minimal functional routes}
\usage{
get_mfrs(
  graph,
  source,
  target,
  method = NULL,
  expand = NULL,
  add.source = NULL,
  silent = TRUE,
  format = "indices"
)

get_minimal_functional_routes(
  graph,
  source,
  target,
  method = NULL,
  expand = NULL,
  add.source = NULL,
  silent = TRUE,
  format = "indices"
)

get_minimal_paths(
  graph,
  source,
  target,
  method = NULL,
  add.source = NULL,
  silent = TRUE,
  format = "indices"
)
}
\arguments{
\item{graph}{An \link[igraph:aaa-igraph-package]{igraph::igraph} object.}

\item{source, target}{Vector of nodes of \code{graph}, as class \code{"igraph.vs"},
integer indices, or character names. \code{source} must have in-degree zero.}

\item{method}{An algorithm from Wang et al (2013) from among the following:
\code{"dfs"} (depth-first search; Algorithm 1), \code{"ilp"} (iterative integer
linear programming; Algorithm 2), or \code{"sgg"} (subgraph-growing; Algorithm
3). \strong{Currently Algorithms 1 and 3 are implemented in C++; Algorithm 3 also
has an implementation in R, employed by passing \code{"sggR"}.}}

\item{expand}{Whether to expand \code{graph} before finding the MFRs and, if so,
to return the list of MFRs in terms of the node and link IDs of \code{graph}
rather than of its expanded graph. If \code{NULL}, \code{graph} will be expanded only
if it has a \code{"synergy"} link attribute.}

\item{add.source}{Whether to add to \code{graph} a source node with a link to each
node passed to \code{source}, and to treat this new node as the source. This may
simplify target and allows to use the subgraph-growing algorithm when some
source nodes are not themselves sources. If \code{NULL}, the source node will be
added only in case the subgraph-growing algorithm is called and at least
one \code{source} node is not a source.}

\item{silent}{Whether to print updates on the progress of the algorithm
(deprecated).}

\item{format}{Whether to return the list of MFRs as vectors of edge IDs
(\code{"indices"}), as edge sequences from \code{graph} (\code{"sequences"}), or as
matrices of head and tail node IDs (\code{"matrices"}).}
}
\description{
The function \code{get_mfrs()} takes a graph \code{graph} (by default
assumed to be expanded) with designated \code{source} and \code{target} nodes and
finds the minimal functional routes (MFRs) from \code{source} to \code{target}.
\code{get_minimal_functional_routes()} is an alias. The function
\code{get_minimal_paths} trivializes the functional annotation of a graph and
uses \code{get_mfrs()} to find minimal paths.
}
\examples{
# MFRs for acyclic example (constructs expanded graph internally)
g <- example_acyclic
g_mfrs <- get_mfrs(g, expand = TRUE, source = "I", target = "O")
par(mfrow = c(2, 3))
for (i in seq_along(g_mfrs)) {
  g <- set_edge_attr(g, "MFR",
                     value = (as.numeric(E(g))) \%in\% g_mfrs[[i]])
  plot(g,
       layout = layout_as_tree,
       vertex.color = ifelse(V(g)$composite, "gray", "white"),
       edge.color = ifelse(edge_attr(g, "MFR"), "red", "black"),
       edge.width = ifelse(edge_attr(g, "MFR"), 3, 1))
}
par(mfrow = c(1, 1))
# MFRs for its expanded graph directly
h <- expand_graph(g)
h_mfrs <- get_mfrs(h, source = 1, target = 10)
par(mfrow = c(2, 3))
for (i in seq_along(h_mfrs)) {
  h <- set_edge_attr(h, "MFR",
                     value = (as.numeric(E(h))) \%in\% h_mfrs[[i]])
  plot(h,
       layout = layout_as_tree,
       vertex.color = ifelse(V(h)$composite, "gray", "white"),
       edge.color = ifelse(edge_attr(h, "MFR"), "red", "black"),
       edge.width = ifelse(edge_attr(h, "MFR"), 3, 1))
}
par(mfrow = c(1, 1))
# MFRs from expanded graph converted back to contracted graph
g_ <- contract_graph(h)
par(mfrow = c(2, 3))
for (i in seq_along(h_mfrs)) {
  g_ <- set_edge_attr(g_, "MFR",
                      value = (as.numeric(E(g_))) \%in\% h_mfrs[[i]])
  plot(g_,
       layout = layout_as_tree,
       vertex.color = ifelse(V(g_)$composite, "gray", "white"),
       edge.color = ifelse(edge_attr(g_, "MFR"), "red", "black"),
       edge.width = ifelse(edge_attr(g_, "MFR"), 3, 1))
}
par(mfrow = c(1, 1))

# color duplicated link
g <- example_acyclic
h <- expand_graph(g)
mfrs <- get_mfrs(h, source = 1, target = 10, format = "sequences")
h <- set_edge_attr(h, "MFR", value = sapply(
  E(h),
  function(i) length(which(mfrs[[3]] == i))
))
plot(
  h, layout = layout_as_tree,
  vertex.color = ifelse(V(h)$composite, "gray", "white"),
  edge.color = c("black", "red", "blue")[unlist(edge_attr(h, "MFR")) + 1],
  edge.width = ifelse(edge_attr(h, "MFR"), 3, 1)
)

# subgraph-growing algorithm: toy examples
graph <- graph(c( 1,3, 2,3 ))
graph <- set_vertex_attr(graph, "composite", value = FALSE)
get_mfrs(graph, source = 1, target = 3, method = "sgg", silent = FALSE)
get_mfrs(graph, source = 1, target = 3, method = "sggR", silent = FALSE)

graph <- graph(c( 1,2, 2,3, 1,3, 3,4 ))
plot(graph, edge.label = E(graph))
graph <- set_vertex_attr(graph, "composite", value = FALSE)
get_mfrs(graph, source = 1, target = 4, method = "sgg", silent = TRUE)
get_mfrs(graph, source = 1, target = 4, method = "sggR", silent = TRUE)

graph <- graph(c( 1,2, 1,3, 2,4, 3,4, 4,5, 3,6, 6,5 ))
plot(graph, edge.label = E(graph))
graph <- set_vertex_attr(graph, "composite", value = as.logical(c(0,0,0,1,0,0)))
get_mfrs(graph, source = 1, target = 5, method = "sgg", format = "matrices")
get_mfrs(graph, source = 1, target = 5, method = "sggR", format = "matrices")

# subgraph-growing algorithm: acyclic example
acyclic_expansion <- expand_graph(example_acyclic)
plot(acyclic_expansion,
     layout = layout_as_tree,
     vertex.color = ifelse(V(acyclic_expansion)$composite, "gray", "white"),
     edge.label = E(acyclic_expansion))
get_mfrs(acyclic_expansion, source = "I", target = "O", method = "dfs")
get_mfrs(acyclic_expansion, source = "I", target = "O", method = "sgg")
get_mfrs(acyclic_expansion, source = "I", target = "O", method = "sggR")

# subgraph-growing algorithm: cyclic example
cyclic_expansion <- expand_graph(example_cyclic)
plot(cyclic_expansion,
     layout = layout_with_fr,
     vertex.color = ifelse(V(cyclic_expansion)$composite, "gray", "white"),
     edge.label = E(cyclic_expansion))
get_mfrs(cyclic_expansion, source = "s", target = "t", method = "sgg")
get_mfrs(cyclic_expansion, source = "s", target = "t", method = "sggR")

\dontrun{
rbenchmark::benchmark(
  get_mfrs(cyclic_expansion, source = "s", target = "t", method = "sgg"),
  get_mfrs(cyclic_expansion, source = "s", target = "t", method = "sggR")
)
rbenchmark::benchmark(
  get_mfrs(acyclic_expansion, source = "I", target = "O", method = "dfs"),
  get_mfrs(acyclic_expansion, source = "I", target = "O", method = "sgg"),
  get_mfrs(acyclic_expansion, source = "I", target = "O", method = "sggR")
)
}
# use MFR functionality to enumerate minimal paths

# acyclic example
g <- example_acyclic
plot(g, edge.label = 1:ecount(g))
get_minimal_functional_routes(g, source = "I", target = "O")
get_minimal_paths(g, source = "I", target = "O")

# cyclic example
g <- example_cyclic
plot(g, edge.label = 1:ecount(g))
get_minimal_functional_routes(g, source = "s", target = "t")
get_minimal_paths(g, source = "s", target = "t")
}
\references{
Wang, R.-S., Sun, Z. & Albert, R. (2013) Minimal functional routes in
directed graphs with dependent links. \emph{Intl. Trans. in Op. Res.}, 20,
391--409.
}
\seealso{
expand_graph
}
