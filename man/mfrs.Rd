% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get-mfrs.r
\name{mfrs}
\alias{mfrs}
\alias{get_mfrs}
\alias{get_minimal_functional_routes}
\alias{get_minimal_paths}
\title{Recover minimal functional routes}
\usage{
get_mfrs(graph, input, output, method = NULL, expand = NULL,
  add.source = NULL, silent = TRUE, format = "sequences")

get_minimal_functional_routes(graph, input, output, method = NULL,
  expand = NULL, add.source = NULL, silent = TRUE,
  format = "sequences")

get_minimal_paths(graph, input, output, method = NULL,
  add.source = NULL, silent = TRUE, format = "sequences")
}
\arguments{
\item{graph}{An object of class \code{"igraph"}.}

\item{input, output}{Nodes of \code{graph}, as \strong{igraph} vertices,
integer indices, or character names. \code{input} must have in-degree zero.}

\item{method}{An algorithm from Wang et al (2013) from among the
following: \code{"dfs"} (depth-first search; Algorithm 1), \code{"ilp"}
(iterative integer linear programming; Algorithm 2), or \code{"sgg"}
(subgraph-growing; Algorithm 3). \strong{Currently Algorithms 1 and 3 are
implemented in C++; Algorithm 3 also has an implementation in R, employed
by passing \code{"sggR"}.}}

\item{expand}{Whether to expand \code{graph} before finding the MFRs and, if
so, to return the list of MFRs in terms of the node and link IDs of
\code{graph} rather than of its expanded graph. If \code{NULL},
\code{graph} will be expanded only if it has a \code{'synergy'} link
attribute.}

\item{add.source}{Whether to add to \code{graph} a source node with a link to
each node passed to \code{input}, and to treat this new node as the input.
This may simplify output and allows to use the subgraph-growing algorithm
when some input nodes are not themselves sources. If \code{NULL}, the
source node will be added only in case the subgraph-growing algorithm is
called and at least one \code{input} node is not a source.}

\item{silent}{Whether to print updates on the progress of the algorithm
(deprecated).}

\item{format}{Whether to return the list of MFRs as \code{"sequences"} of
link IDs or as \code{"matrices"} of head and tail node IDs.}
}
\description{
This function takes a graph \code{graph} (by default assumed to be expanded)
with designated \code{input} and \code{output} nodes and finds the minimal
functional routes (MFRs) from \code{input} to \code{output}.
}
\examples{
# MFRs for acyclic example (constructs expanded graph internally)
g <- example_acyclic
g_mfrs <- get_mfrs(g, expand = TRUE, input = "I", output = "O")
par(mfrow = c(2, 3))
for (i in seq_along(g_mfrs)) {
  g <- set_edge_attr(g, "MFR",
                     value = (as.numeric(E(g))) \%in\% g_mfrs[[i]])
  plot(g,
       layout = layout_as_tree,
       vertex.color = ifelse(V(g)$composite, "gray", "white"),
       edge.color = ifelse(edge_attr(g, "MFR"), "red", "black"),
       edge.width = ifelse(edge_attr(g, "MFR"), 3, 1))
}
par(mfrow = c(1, 1))
# MFRs for its expanded graph directly
h <- expand_graph(g)
h_mfrs <- get_mfrs(h, input = 1, output = 10)
par(mfrow = c(2, 3))
for (i in seq_along(h_mfrs)) {
  h <- set_edge_attr(h, "MFR",
                     value = (as.numeric(E(h))) \%in\% h_mfrs[[i]])
  plot(h,
       layout = layout_as_tree,
       vertex.color = ifelse(V(h)$composite, "gray", "white"),
       edge.color = ifelse(edge_attr(h, "MFR"), "red", "black"),
       edge.width = ifelse(edge_attr(h, "MFR"), 3, 1))
}
par(mfrow = c(1, 1))
# MFRs from expanded graph converted back to contracted graph
g_ <- contract_graph(h)
par(mfrow = c(2, 3))
for (i in seq_along(h_mfrs)) {
  g_ <- set_edge_attr(g_, "MFR",
                      value = (as.numeric(E(g_))) \%in\% h_mfrs[[i]])
  plot(g_,
       layout = layout_as_tree,
       vertex.color = ifelse(V(g_)$composite, "gray", "white"),
       edge.color = ifelse(edge_attr(g_, "MFR"), "red", "black"),
       edge.width = ifelse(edge_attr(g_, "MFR"), 3, 1))
}
par(mfrow = c(1, 1))

# color duplicated link
g <- example_acyclic
h <- expand_graph(g)
mfrs <- get_mfrs(h, input = 1, output = 10)
h <- set_edge_attr(h, "MFR", value = sapply(
  as.numeric(E(h)),
  function(i) length(which(mfrs[[3]] == i))
))
plot(
  h, layout = layout_as_tree,
  vertex.color = ifelse(V(h)$composite, "gray", "white"),
  edge.color = c("black", "red", "blue")[unlist(edge_attr(h, "MFR")) + 1],
  edge.width = ifelse(edge_attr(h, "MFR"), 3, 1)
)

# subgraph-growing algorithm: toy examples
graph <- graph(c( 1,3, 2,3 ))
graph <- set_vertex_attr(graph, "composite", value = FALSE)
get_mfrs(graph, input = 1, output = 3, method = "sgg", silent = FALSE)
get_mfrs(graph, input = 1, output = 3, method = "sggR", silent = FALSE)

graph <- graph(c( 1,2, 2,3, 1,3, 3,4 ))
plot(graph, edge.label = E(graph))
graph <- set_vertex_attr(graph, "composite", value = FALSE)
get_mfrs(graph, input = 1, output = 4, method = "sgg", silent = TRUE)
get_mfrs(graph, input = 1, output = 4, method = "sggR", silent = TRUE)

graph <- graph(c( 1,2, 1,3, 2,4, 3,4, 4,5, 3,6, 6,5 ))
plot(graph, edge.label = E(graph))
graph <- set_vertex_attr(graph, "composite", value = as.logical(c(0,0,0,1,0,0)))
get_mfrs(graph, input = 1, output = 5, method = "sgg")
get_mfrs(graph, input = 1, output = 5, method = "sggR")

# subgraph-growing algorithm: acyclic example
acyclic_expansion <- expand_graph(example_acyclic)
plot(acyclic_expansion,
     layout = layout_as_tree,
     vertex.color = ifelse(V(acyclic_expansion)$composite, "gray", "white"),
     edge.label = E(acyclic_expansion))
get_mfrs(acyclic_expansion, input = "I", output = "O", method = "dfs")
get_mfrs(acyclic_expansion, input = "I", output = "O", method = "sgg")
get_mfrs(acyclic_expansion, input = "I", output = "O", method = "sggR")

# subgraph-growing algorithm: cyclic example
cyclic_expansion <- expand_graph(example_cyclic)
plot(cyclic_expansion,
     layout = layout_with_fr,
     vertex.color = ifelse(V(cyclic_expansion)$composite, "gray", "white"),
     edge.label = E(cyclic_expansion))
get_mfrs(cyclic_expansion, input = "s", output = "t", method = "sgg")
get_mfrs(cyclic_expansion, input = "s", output = "t", method = "sggR")

\dontrun{
rbenchmark::benchmark(
  get_mfrs(cyclic_expansion, input = "s", output = "t", method = "sgg"),
  get_mfrs(cyclic_expansion, input = "s", output = "t", method = "sggR")
)
rbenchmark::benchmark(
  get_mfrs(acyclic_expansion, input = "I", output = "O", method = "dfs"),
  get_mfrs(acyclic_expansion, input = "I", output = "O", method = "sgg"),
  get_mfrs(acyclic_expansion, input = "I", output = "O", method = "sggR")
)
}
# use MFR functionality to enumerate minimal paths

# acyclic example
g <- example_acyclic
plot(g, edge.label = 1:ecount(g))
get_minimal_functional_routes(g, input = "I", output = "O")
get_minimal_paths(g, input = "I", output = "O")

# cyclic example
g <- example_cyclic
plot(g, edge.label = 1:ecount(g))
get_minimal_functional_routes(g, input = "s", output = "t")
get_minimal_paths(g, input = "s", output = "t")
}
\references{
Wang, R.-S., Sun, Z. & Albert, R. (2013) Minimal functional routes in 
directed graphs with dependent links. \emph{Intl. Trans. in Op. Res.}, 20, 
391--409.
}
\seealso{
expand_graph
}
